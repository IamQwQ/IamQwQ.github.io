{"posts":[{"title":"关于喝咖啡反而更加犯困的问题","content":"以前在和朋友絮叨日常的时候偶尔会听到喝咖啡困的事，开始并没有仔细琢磨，权当是抱怨和哗众取宠了。但是随着时间的流逝，耳闻越来越多的人提到过这方面的事，刚好最近刚写完关于咖啡的事，又突然想起来这件事，顺便翻了翻资料查了一下。 开始是从咖啡的作用过程开始查的，然后就发现= = 1.竞争性地阻断腺苷受体。2.竞争性地结合苯二氮卓类受体，限制了CI通道的开放。3.使cAMP增多。这是药理作用机制。小剂量的咖啡因能兴奋大脑皮层，因此能提神。而较大剂量能收缩脑血管，故此能够镇痛，但是会成瘾。 咖啡因是如何作用于人体的？ - 蔡卫纯的回答 - 知乎 https://www.zhihu.com/question/19958348/answer/13476426 u1s1，最开始的时候是看不懂的。 但对于理解&quot;关于喝咖啡反而更加犯困的问题&quot;来说，我认为理解作用过程是非必要的，所以如果这里不求甚解也是可以的。 埃森克提出**外向的人大脑皮层的抑制过程强而兴奋过程弱，他们的神经系统非常发达，对刺激有很强的忍受能力。而内向的人的皮层兴奋过程强而抑制过程弱，所以忍受刺激的能力有限。**因此，对外向的人来说他们的大脑对刺激的反应慢且微弱，他们是刺激的寻求者，渴望强烈的感觉刺激，这使得他们通过各种方式来寻求兴奋，他们喜欢参加派对、交朋友、冒险等。相反，内向性格的人天生皮层刺激唤醒水平高，对刺激的反应既迅速又强烈，他们只能忍受微弱的刺激，所以更喜欢阅读、写作、下棋等活动。有研究表明，外向性格的人很早就寻求社会关系，他们的社交技巧发展完善，而社交活动是他们快乐的一大源泉，并且培养了他们自信解决问题的能力。极端外向的人只是在避免无聊，他们的问题是要满足对刺激的需要。 为什么有些人喝咖啡反而更加犯困？ - 范不说的回答 - 知乎 https://www.zhihu.com/question/25286099/answer/865648712 上面转载的回答有些地方表述的有些模糊，这个理论是艾森克的外-内倾概念，除了具有其本身的一般含义外还与神经系统的兴奋过程和抑制过程相联系，他发现： 兴奋过程可以易化[1]正在进行的感觉、认知和活动；抑制过程可以干扰或影响有机体正在进行的感觉、认知和活动。 他发现高外倾性的人兴奋过程发生慢、强度弱、持续时间短，而抑制过程发生快、强度强、维持时间长。这种人难以形成条件反射。高内倾性的人兴奋过程发生快、强度强、持续时间长，而抑制过程发生慢、强度弱、维持时间短。这种人容易形成条件反射。 这是外倾性和内倾性的定义： 瑞士心理学家C.G.荣格于1931年提出的人格类型概念，与内倾相对应。荣格认为,如果一人的心理能量,他的兴趣和注意一般指向外部，指向他人或外部刺激，其行为主要是由外界事物而不是他们个人的思想感情所指导，那么这个人主要是外倾的，否则就是内倾的。 高外倾性的人因为抑制过程作用太强所以对于刺激的接受能力很强，高内倾性的人因为抑制过程效果不高所以更喜欢微弱的刺激，但是咖啡因是直接作用大脑皮层，就算高内倾性的人不喜欢为什么会反而困呢？ 这里涉及到一个名词就是最佳皮质唤醒水平（现在多称为&quot;唤醒水平&quot;） 动机理论里面有一个是理论是唤醒水平理论，就是指人都追求一个最佳的唤醒水平，这个唤醒水平一般比较适中。所以如果是内向的人，本身有较高的唤醒水平，就不需要太多的外界刺激了，否则就会超过最佳唤醒水平。 唤醒指在刺激作用下通过脑干的网状结构提高大脑皮层的兴奋性，同时加强肌肉的紧张状态 如果本身就处在最佳的唤醒水平，超过了这个量，在baidu百科定义中是这样表述的 一般人偏好中等唤醒水平，导致最佳唤醒。过高和过低都将导致不好的表现。 （虽然没说&quot;不好的表现是指什么&quot;） 易化是局部阈下兴奋状态能使神经元兴奋性升高的现象。 ↩︎ ","link":"https://IamQwQ.github.io/post/polyhedronCoffeeMakesPeopleSleepy/"},{"title":"Java 面向对象","content":"初识类 类是面向对象思想中的核心部分，我们通过类来实例化出对象。 如何理解类和实例化呢？ 类在面向对象思想中应当是抽象、概念的，比如一条狗，他有着相当多的属性和行为，这些属性和行为全部封装在这个类中。 而实例化就是从抽象的类中实际刻画出一个对象来，只有实例化之后一个对象之后才能调用其属性和行为。 构成类的成员 上文说过类中存在属性和行为，属性对应代码中的成员变量及常量(统称字段)，而行为则对应方法。除了字段和方法，类还有以下成员 构造方法 内部类 初始化块 字段 在方法中定义的变量常量称之为局部变量/常量，这两种量的生命周期仅存于方法的开始到方法的结束。 而在类当中、方法之外定义的变量常量称之为成员变量/常量，统称字段，他的生命周期比局部变量/常量要长一些。 而字段的生命周期会直到GC将对象回收为止 Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，在使用JAVA的时候，一般不需要专门编写内存回收和垃圾清理代 码。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。 电脑的内存大小的不变的，当我们使用对象的时候，如使用New关键字的时候，就会在内存中生产一个对象，但是我们在使用JAVA开发的时候，当一个对象使用完毕之后我们并没有手动的释放那个对象所占用的内存，就这样在使用程序的过程中，对象越来越多，当内存存放不了这么多对象的时候，电脑就会崩溃了，JAVA为了解决这个问题就推出了这个自动清除无用对象的功能，或者叫机制，这就是GC，有个好听是名字叫垃圾回收，其实就在用来帮你擦屁股的，好让你安心写代码，不用管内存释放，对象清理的事情了。 上述内容仅作了解即可。 class Table{ //字段 成员变量 //品牌 String brand; //颜色 String color; //高度 int height; } 方法 行为对应的是代码中的方法，它也应被定义在类中。 class Mouse{ //字段 成员变量 //重量 int weight; //颜色 String color; //方法 //虽然我们现在没有能力写出让老鼠真正的偷吃东西 //但是我们可以让他输出一句话作为一个简单的例子 void eatSomeThing(){ System.out.println(&quot;偷吃东西&quot;); } } 实例化 实例化的语法： 类名 实例名; 实例名 = new 类名(); 类名 实例名 = new 类名(); 调用字段和方法的语法： 实例.字段名; 实例.方法名(参数); //如果方法无参则不填参数 此处以Mouse类为例子进行实例化： class Mouse{ //字段 成员变量 //重量 int weight; //颜色 String color; //方法 void eatSomeThing(){ System.out.println(&quot;Mouse偷吃了东西&quot;); } } class Test{ public static void main(String[] args){ //实例化Mouse类 Mouse m = new Mouse(); //调用Mouse类的字段并赋值 m.weight = 10; //调用Mouse类的方法 m.eatSomeThing(); //输出一下weight字段查看老鼠的大小 (可能是变异鼠 233) System.out.println(&quot;老鼠有&quot;+m.weight+&quot;公斤&quot;); } } static修饰符 static修饰的字段、方法或者内部类会在类加载的时候就一并加载，被static修饰的字段、方法或者内部类同时也多了一种可以被调用的方式： 类名.字段名; 类名.方法名(); 一般的类都是把字段和方法封装在其中的，如果调用则需要进行实例化，但被static修饰的是在类加载时就一并加载的，所以不需要实例化。 被static修饰的成员被称作为静态成员，反之则被称为实例成员，以下是对静态成员特点的总结： 类一旦被加载、其也被加载 静态成员优先于实例成员 静态成员多了一种被调用的方式：类名.字段名/类名.方法名 访问控制修饰符 访问控制符也分修饰的对象是什么，其中有类修饰符，有方法修饰符和变量修饰符，此分支记录的是访问控制符。 [权限范围表](C:\\Users\\HP2020\\Documents\\XiaoMiNet\\Upupoo\\Docker\\config\\ide及工具\\快码阿 怎么不码了\\Java\\java 基础\\修饰符作用范围.md) 类修饰符 public java的类的访问控制符仅有public一个，每个java程序有且仅有一个类是被public修饰的，那就是主类。 字段和方法修饰符 public public是指公共访问控制符，对任何访问他的人公开，具体一些：在类内、package内、子类内和其他package中都可以被访问。 公共访问控制符 public：用 public 修饰的域称为公共域。由于 public 修饰符会降低运行的安全性和数据的封装性，所以一般应减少 public 域的使用。 protected protected是指保护访问控制符，不对其他package开放访问权。 default default是为默认的控制符，不对其他package和子类开放访问权，仅对本类和所在package内开放访问。 private private是指私有访问控制符，仅对本类开放访问权。 匿名对象 当要访问某个方法时，我们总是要先进行实例化，但如果我们只需要进行一次访问，进行实例化就显得有点子麻烦..毕竟要花两行代码呢（？） 如果我们能够直接访问某个方法就足够方便了，匿名对象就是专为临时访问而生的功能，我们进行实例化时不指向任何实例，而是通过这个对象直接访问其字段和方法。 下面的例子还是以最开始的老鼠类为基础写的： new Mouse().eatSomeThing(); 但是需要注意的是，因为匿名对象创建对象时没有指向任何实例，所以java把他视为垃圾，在不久之后就会清除掉，因此对其中的变量赋值是没有意义的。 如果要使用多个方法或字段则还是需要进行实例化。 使用匿名对象传参 使用对象进行传参时同上述所说原理一样，也可以不使用实例传参，可以视情况直接使用匿名对象的方式传参。 //主类 class main{ //入口函数 public static void main(String[] args){ //此处使用了静态函数的调用方法并使用了匿名对象传参 System.out.println(Calculate.circalPerimeter(new Data().r)); } } //计算类 class Calculate{ //计算圆周长方法 (此处方便调用简单设为静态) public static double circalPerimeter(int r){ //PI*d是圆周长公式 return (r*2*3.14); } } //数据类 class Data{ //此处存储了半径变量 int r = 5; } 面向对象是一种编程思想，此处既然说到面向对象就不得不提到另一种与其相对的思想：面向过程 面向过程与面向对象的区别 在面向过程中，我们通常先分析事情所需要的步骤和过程，以一个学生的日常来说： 起床 穿衣 洗漱 上学 而这4步就是一步一步地完成，它的顺序很重要，你只需要一个一个地实现就行了。 他的思想重点在于他的过程，程序的流程就是一个函数调用另外一个函数，而这个函数又再调用其他的函数，这里再举一个吃西瓜的例子，当使用面向过程的思想去实现一个人吃西瓜时，直接写一个吃函数，吃什么？吃西瓜参数。 而面向对象则需要建立一个人的实体，由实体引发事件，先抽象出一个&quot;人&quot;类，在这个&quot;人&quot;类里有一些人的基本属性，如身高，年龄；人还会有行为，所以&quot;人&quot;类中还有方法，走方法，说话方法，吃方法，喝方法等等... 此时需求是让人吃西瓜，所以把抽象的类实例出一个人出来，最终让 人.吃(西瓜)； 而且面向对象丰富的特性(如继承、多态)使得其十分灵活，而面向过程则显得十分笨重 应对新需求时，无需更改已经测试通过的既有的类。它良好的灵活性和拓展性仿佛天生就是用来适应变化的。 ","link":"https://IamQwQ.github.io/post/javaOop/"},{"title":"我和咖啡","content":"写这篇记录之前，我本想去起笔去写java的东西的，但现在是一个晚上，本来精神不振，混混沉沉，所以生出了买瓶装咖啡的想法，现在一瓶咖啡一块面包下肚，配合网易云食用霎时间精神焕发，据主观推测不出意料的话应该是要过美国人的时间表了.. “咖啡”一词源自阿拉伯语“قهوة”，意思是“植物饮料”。在世界各地，人们越来越爱喝咖啡。随之而来的“咖啡文化”充满生活的每个时刻。无论在家里、还是在办公室、或是各种社交场合，人们都在品着咖啡、它逐渐与时尚、现代生活、工作和休闲娱乐联系在一起。 咖啡豆含有大约100种不同的物质，包括咖啡因、单宁酸、油和氮化合物等，每100克速溶咖啡中，含咖啡因44～100毫克；每100克调制咖啡中，含咖啡因64～124毫克。咖啡是一种兴奋剂，对人体会产生很多影响，它可利尿、刺激中枢神经和呼吸系统、扩大血管、使心跳加速、增强横纹肌的力量以及缓解大脑和肌肉疲劳。 实实在在的说，接触咖啡的原因是其功能性。虽然很想说是因为其味道独特，入口如何如何，咽下回味又如何如何，但很遗憾，饮用咖啡的绝大多数时候都是觉得需要提神，而且我觉得应该有不会少的人都是因为这个而去喝咖啡的吧。 为什么喝苦咖啡？ 喝美式低糖的时候确实很苦，只是一开始的时候会这么想，缘于其功效也比其他咖啡要强的多，所以从接触之后时不时就想整一瓶，后来再喝的时候苦的感受却没有那么强烈了，喝下去的时候确实是苦的，但是却忍不住一口一口再喝下去，难道是觉醒了奇怪的品味属性( ? )，凭心而论，喝的时候没有那么仔细品味。后来找到了一个简单的答案： 当你习惯了，它就是美味了。 ","link":"https://IamQwQ.github.io/post/aboutCoffee/"},{"title":"Java Swing组件","content":"Swing基本介绍 awt是java1.0中的基础类(抽象窗口工具箱) 为了给程序员构建一个通用的gui使其能够在所有的平台上运行，但没有达到预期的效果，所以有了swing swing不能代替awt，所以swing和awt是需要同时出现在一个图形用户界面当中 swing组件特点 轻量级 可插入外观组件 Swing的常用窗体及其常用方法 窗体是各个组件的载体，下图为组件和窗体的关系 JFrame窗体 拥有边界和最大化、最小化和关闭的顶层窗口 JFrame jf = new JFrame(&quot;this is a test&quot;); Container container = jf.getContentPane(); jf是JFrame对象 container是Container对象，可以使用JFrame对象调用getContentPane()方法获取，实际上就是获取当前窗口的内容窗格 swing组件的窗体通常与组件和容器有关，所以JFrame对象创建完成后，需要调用getContentPane() 方法将窗体转换为容器，然后在容器中添加组件或者设置布局管理器 Q：或许如果自己码字会发现，不使用getContentPane()也是可以直接添加组件的阿，那么getContentPane()方法的意义何在呢？ A：点击跳转至getContentPane的意义研究 容器已经准备好了，此时如果需要把组件添加进容器的话可以使用Container类的add方法 Button testButton = new Button(&quot;test button&quot;); container.add(testButton); 阿 常用的方法有空再补上 以下是一个swing显示图片的实例 import javax.swing.* import java.awt.* public class test{ public static void main(String[] args){ } public static void newwindows(String title){ //创建JFrame对象 JFrame jf = new JFrame(title); //转换为内容窗口对象 //(此处设置颜色使用container对象的原因是rootpane显示在最上层 所以要通过内容窗格来设置颜色) Container container = jf.getContentPane(); //窗口设置 //设置窗口关闭方式 jf.setDefaultCloseOperation(WindowConstant.Exit_On_Close); //设置窗口窗顶栏不可见 (设置不加修饰) jf.setUndecorated(true); //设置窗口可见 jf.setVisible(true); //设置窗口透明程度 jf.setOpacity(0.5); //窗口颜色 container.setBackground(Color.black); //组件设置 //创建JLable标签 JLable jl = new JLable(); //创建imageicon对象用来创建icon图符 ImageIcon icon = new ImageIcon(url[此处指url变量]); //seticon方法将icon添加至jl中 jl.setIcon(icon); //将jl添加至容器中 container.add(jl); } } ","link":"https://IamQwQ.github.io/post/javaSwingAssembly/"},{"title":"TestPage","content":"&quot;test test&quot; markdown is ready ","link":"https://IamQwQ.github.io/post/testpage/"}]}