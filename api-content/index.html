{"posts":[{"title":"另辟捷径的数字排列方式","content":"本文多数内容转载于b站up主oooooohmygosh与ttttttiger虎的视频 传送门 本篇内容后续还会更新其原理及其思路研究；；；代码还也没往上写；；（看视频更方便） 我们在对若干数字进行排列的时候总是会先去寻找数列中最小或最大的数字放在数列的最前或最后，就像是这样： 3 5 8 *1* 2 9 4 7 6 选取最小进行置于队列首位重新排列 1 3 5 8 *2* 9 4 6 7 重复操作 1 2 3 5 8 9 4 6 7 依此类推 但传统的思路在面对大量的数字时速度就直线下降 3 5 8 1 2 9 4 7 6 先在数列中选择一个&quot;标准&quot; 此处选择6 3 5 8 1 2 9 4 7 *6* 在标准的最左边的数字和最右边的数字进行标记 3 5 8 1 2 9 4 7 *6* 将左边的标记向右移动，直到标记的数字大于标准时停下 右边的标记向左移动，直到标记的数字小于标准时停下 3 5 8 1 2 9 4 7 *6* 此时将两个标记位置交换 3 5 4 1 2 9 8 7 *6* 再次重复上一过程 3 5 4 1 2 9 8 7 *6* 此时两个标记相撞了;;; 如果标记的位置重叠，则将标记的位置与标准的位置交换 3 5 4 1 2 *6* 8 7 9 当标准与标记进行位置交换之后，标准的左边就全部都是 小于标准的数字了，同理，右边则都是大于标准的数字 此时设置新的标准 3 5 4 1 *2* 6 8 7 9 重复重复重复(‾◡◝);; 可见该方法的排序次数之少，效率可想而知 阿...有空把代码试一遍；；； ","link":"https://IamQwQ.github.io/post/numbersArrangement/"},{"title":"Java 面向对象","content":"初识类 类是面向对象思想中的核心部分，我们通过类来实例化出对象。 如何理解类和实例化呢？ 类在面向对象思想中应当是抽象、概念的，比如一条狗，他有着相当多的属性和行为，这些属性和行为全部封装在这个类中。 而实例化就是从抽象的类中实际刻画出一个对象来，只有实例化之后一个对象之后才能调用其属性和行为。 构成类的成员 上文说过类中存在属性和行为，属性对应代码中的成员变量及常量(统称字段)，而行为则对应方法。除了字段和方法，类还有以下成员 构造方法 内部类 初始化块 字段 在方法中定义的变量常量称之为局部变量/常量，这两种量的生命周期仅存于方法的开始到方法的结束。 而在类当中、方法之外定义的变量常量称之为成员变量/常量，统称字段，他的生命周期比局部变量/常量要长一些。 而字段的生命周期会直到GC将对象回收为止 Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，在使用JAVA的时候，一般不需要专门编写内存回收和垃圾清理代 码。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。 电脑的内存大小的不变的，当我们使用对象的时候，如使用New关键字的时候，就会在内存中生产一个对象，但是我们在使用JAVA开发的时候，当一个对象使用完毕之后我们并没有手动的释放那个对象所占用的内存，就这样在使用程序的过程中，对象越来越多，当内存存放不了这么多对象的时候，电脑就会崩溃了，JAVA为了解决这个问题就推出了这个自动清除无用对象的功能，或者叫机制，这就是GC，有个好听是名字叫垃圾回收，其实就在用来帮你擦屁股的，好让你安心写代码，不用管内存释放，对象清理的事情了。 上述内容仅作了解即可。 class Table{ //字段 成员变量 //品牌 String brand; //颜色 String color; //高度 int height; } 方法 行为对应的是代码中的方法，它也应被定义在类中。 class Mouse{ //字段 成员变量 //重量 int weight; //颜色 String color; //方法 //虽然我们现在没有能力写出让老鼠真正的偷吃东西 //但是我们可以让他输出一句话作为一个简单的例子 void eatSomeThing(){ System.out.println(&quot;偷吃东西&quot;); } } 实例化 实例化的语法： 类名 实例名; 实例名 = new 类名(); 类名 实例名 = new 类名(); 调用字段和方法的语法： 实例.字段名; 实例.方法名(参数); //如果方法无参则不填参数 此处以Mouse类为例子进行实例化： class Mouse{ //字段 成员变量 //重量 int weight; //颜色 String color; //方法 void eatSomeThing(){ System.out.println(&quot;Mouse偷吃了东西&quot;); } } class Test{ public static void main(String[] args){ //实例化Mouse类 Mouse m = new Mouse(); //调用Mouse类的字段并赋值 m.weight = 10; //调用Mouse类的方法 m.eatSomeThing(); //输出一下weight字段查看老鼠的大小 (可能是变异鼠 233) System.out.println(&quot;老鼠有&quot;+m.weight+&quot;公斤&quot;); } } static修饰符 static修饰的字段、方法或者内部类会在类加载的时候就一并加载，被static修饰的字段、方法或者内部类同时也多了一种可以被调用的方式： 类名.字段名; 类名.方法名(); 一般的类都是把字段和方法封装在其中的，如果调用则需要进行实例化，但被static修饰的是在类加载时就一并加载的，所以不需要实例化。 被static修饰的成员被称作为静态成员，反之则被称为实例成员，以下是对静态成员特点的总结： 类一旦被加载、其也被加载 静态成员优先于实例成员 静态成员多了一种被调用的方式：类名.字段名/类名.方法名 访问控制修饰符 访问控制符也分修饰的对象是什么，其中有类修饰符，有方法修饰符和变量修饰符，此分支记录的是访问控制符。 [权限范围表](C:\\Users\\HP2020\\Documents\\XiaoMiNet\\Upupoo\\Docker\\config\\ide及工具\\快码阿 怎么不码了\\Java\\java 基础\\修饰符作用范围.md) 类修饰符 public java的类的访问控制符仅有public一个，每个java程序有且仅有一个类是被public修饰的，那就是主类。 字段和方法修饰符 public public是指公共访问控制符，对任何访问他的人公开，具体一些：在类内、package内、子类内和其他package中都可以被访问。 公共访问控制符 public：用 public 修饰的域称为公共域。由于 public 修饰符会降低运行的安全性和数据的封装性，所以一般应减少 public 域的使用。 protected protected是指保护访问控制符，不对其他package开放访问权。 default default是为默认的控制符，不对其他package和子类开放访问权，仅对本类和所在package内开放访问。 private private是指私有访问控制符，仅对本类开放访问权。 匿名对象 当要访问某个方法时，我们总是要先进行实例化，但如果我们只需要进行一次访问，进行实例化就显得有点子麻烦..毕竟要花两行代码呢（？） 如果我们能够直接访问某个方法就足够方便了，匿名对象就是专为临时访问而生的功能，我们进行实例化时不指向任何实例，而是通过这个对象直接访问其字段和方法。 下面的例子还是以最开始的老鼠类为基础写的： new Mouse().eatSomeThing(); 但是需要注意的是，因为匿名对象创建对象时没有指向任何实例，所以java把他视为垃圾，在不久之后就会清除掉，因此对其中的变量赋值是没有意义的。 如果要使用多个方法或字段则还是需要进行实例化。 使用匿名对象传参 使用对象进行传参时同上述所说原理一样，也可以不使用实例传参，可以视情况直接使用匿名对象的方式传参。 //主类 class main{ //入口函数 public static void main(String[] args){ //此处使用了静态函数的调用方法并使用了匿名对象传参 System.out.println(Calculate.circalPerimeter(new Data().r)); } } //计算类 class Calculate{ //计算圆周长方法 (此处方便调用简单设为静态) public static double circalPerimeter(int r){ //PI*d是圆周长公式 return (r*2*3.14); } } //数据类 class Data{ //此处存储了半径变量 int r = 5; } 面向对象是一种编程思想，此处既然说到面向对象就不得不提到另一种与其相对的思想：面向过程 面向过程与面向对象的区别 在面向过程中，我们通常先分析事情所需要的步骤和过程，以一个学生的日常来说： 起床 穿衣 洗漱 上学 而这4步就是一步一步地完成，它的顺序很重要，你只需要一个一个地实现就行了。 他的思想重点在于他的过程，程序的流程就是一个函数调用另外一个函数，而这个函数又再调用其他的函数，这里再举一个吃西瓜的例子，当使用面向过程的思想去实现一个人吃西瓜时，直接写一个吃函数，吃什么？吃西瓜参数。 而面向对象则需要建立一个人的实体，由实体引发事件，先抽象出一个&quot;人&quot;类，在这个&quot;人&quot;类里有一些人的基本属性，如身高，年龄；人还会有行为，所以&quot;人&quot;类中还有方法，走方法，说话方法，吃方法，喝方法等等... 此时需求是让人吃西瓜，所以把抽象的类实例出一个人出来，最终让 人.吃(西瓜)； 而且面向对象丰富的特性(如继承、多态)使得其十分灵活，而面向过程则显得十分笨重 应对新需求时，无需更改已经测试通过的既有的类。它良好的灵活性和拓展性仿佛天生就是用来适应变化的。 ","link":"https://IamQwQ.github.io/post/javaOop/"},{"title":"我和 「咖啡」","content":"写这篇记录之前，我本想去起笔去写java的东西的，但现在是一个晚上，本来精神不振，混混沉沉，所以生出了买瓶装咖啡的想法，现在一瓶咖啡一块面包下肚，配合网易云食用霎时间精神焕发，据主观推测不出意料的话应该是要过美国人的时间表了.. “咖啡”一词源自阿拉伯语“قهوة”，意思是“植物饮料”。在世界各地，人们越来越爱喝咖啡。随之而来的“咖啡文化”充满生活的每个时刻。无论在家里、还是在办公室、或是各种社交场合，人们都在品着咖啡、它逐渐与时尚、现代生活、工作和休闲娱乐联系在一起。 咖啡豆含有大约100种不同的物质，包括咖啡因、单宁酸、油和氮化合物等，每100克速溶咖啡中，含咖啡因44～100毫克；每100克调制咖啡中，含咖啡因64～124毫克。咖啡是一种兴奋剂，对人体会产生很多影响，它可利尿、刺激中枢神经和呼吸系统、扩大血管、使心跳加速、增强横纹肌的力量以及缓解大脑和肌肉疲劳。 实实在在的说，接触咖啡的原因是其功能性。虽然很想说是因为其味道独特，入口如何如何，咽下回味又如何如何，但很遗憾，饮用咖啡的绝大多数时候都是觉得需要提神，而且我觉得应该有不会少的人都是因为这个而去喝咖啡的吧。 为什么喝苦咖啡？ 喝美式低糖的时候确实很苦，只是一开始的时候会这么想，缘于其功效也比其他咖啡要强的多，所以从接触之后时不时就想整一瓶，后来再喝的时候苦的感受却没有那么强烈了，喝下去的时候确实是苦的，但是却忍不住一口一口再喝下去，难道是觉醒了奇怪的品味属性( ? )，凭心而论，喝的时候没有那么仔细品味。后来找到了一个简单的答案： 当你习惯了，它就是美味了。 ","link":"https://IamQwQ.github.io/post/aboutCoffee/"},{"title":"Java Swing组件","content":"Swing基本介绍 awt是java1.0中的基础类(抽象窗口工具箱) 为了给程序员构建一个通用的gui使其能够在所有的平台上运行，但没有达到预期的效果，所以有了swing swing不能代替awt，所以swing和awt是需要同时出现在一个图形用户界面当中 swing组件特点 轻量级 可插入外观组件 Swing的常用窗体及其常用方法 窗体是各个组件的载体，下图为组件和窗体的关系 JFrame窗体 拥有边界和最大化、最小化和关闭的顶层窗口 JFrame jf = new JFrame(&quot;this is a test&quot;); Container container = jf.getContentPane(); jf是JFrame对象 container是Container对象，可以使用JFrame对象调用getContentPane()方法获取，实际上就是获取当前窗口的内容窗格 swing组件的窗体通常与组件和容器有关，所以JFrame对象创建完成后，需要调用getContentPane() 方法将窗体转换为容器，然后在容器中添加组件或者设置布局管理器 Q：或许如果自己码字会发现，不使用getContentPane()也是可以直接添加组件的阿，那么getContentPane()方法的意义何在呢？ A：点击跳转至getContentPane的意义研究 容器已经准备好了，此时如果需要把组件添加进容器的话可以使用Container类的add方法 Button testButton = new Button(&quot;test button&quot;); container.add(testButton); 阿 常用的方法有空再补上 以下是一个swing显示图片的实例 import javax.swing.* import java.awt.* public class test{ public static void main(String[] args){ } public static void newwindows(String title){ //创建JFrame对象 JFrame jf = new JFrame(title); //转换为内容窗口对象 //(此处设置颜色使用container对象的原因是rootpane显示在最上层 所以要通过内容窗格来设置颜色) Container container = jf.getContentPane(); //窗口设置 //设置窗口关闭方式 jf.setDefaultCloseOperation(WindowConstant.Exit_On_Close); //设置窗口窗顶栏不可见 (设置不加修饰) jf.setUndecorated(true); //设置窗口可见 jf.setVisible(true); //设置窗口透明程度 jf.setOpacity(0.5); //窗口颜色 container.setBackground(Color.black); //组件设置 //创建JLable标签 JLable jl = new JLable(); //创建imageicon对象用来创建icon图符 ImageIcon icon = new ImageIcon(url[此处指url变量]); //seticon方法将icon添加至jl中 jl.setIcon(icon); //将jl添加至容器中 container.add(jl); } } ","link":"https://IamQwQ.github.io/post/javaSwingAssembly/"},{"title":"TestPage","content":"&quot;test test&quot; markdown is ready ","link":"https://IamQwQ.github.io/post/testpage/"}]}